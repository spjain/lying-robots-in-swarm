########################################
#
# Creates a new belief vector with the given value
function belief_new(v) {
  var b = {}
  var i = 0
  while(i < num_patterns) {
    b[i] = v
    i = i + 1
  }
  return b
}

########################################
#
# Normalize belief
function belief_normalize(bel) {
  var sum = reduce(bel, function(k,v,s) { return s + v}, 0.0 )
  return map(bel, function(k,v) { return v / sum })
}

########################################
#
# Performs the sensing-based part of the belief update
function belief_update_sensing(bel) {
  # Get actual ground readings and make sure they're the same for all sensors
  if((ground[0].value != ground[1].value) or (ground[0].value != ground[2].value) or (ground[0].value != ground[3].value)) {
    # Readings are not the same, skip calculations
    return bel
  }
  var act_read = (ground[0].value > 0.0)
  # Calculate the arena position of the center of mass of the ground sensors
  var gndpos = reduce(ground, function(k,v,sum) { return math.vec2.add(sum, v.offset) }, math.vec2.new(0.0, 0.0))
  gndpos = math.vec2.scale(gndpos, 0.25)
  gndpos = math.vec2.rotate(gndpos, pose.orientation.yaw)
  gndpos = math.vec2.add(gndpos, pose.position)
  # Get current cell index
  var idx = pos_to_cell(gndpos.x, gndpos.y)
  # Calculate new belief
  return map(bel, function(k, v) {
      # Get expected reading
      var exp_read = ((k & (1 << idx)) > 0)
      # Calculate new prob
      if(exp_read == act_read) {
        return v * (1-noise_prob) + EPSILON
      }
      else {
        return v * noise_prob + EPSILON
      }
    })
}

########################################
#
# Loop function variables
function belief_update_lf(bel) {
  # Set probability of correct pattern
  correct_pattern_prob = bel[pattern]
  # Set index of picked pattern
  picked_pattern_num = 0
  picked_pattern = reduce(bel,
    function(k,v,idx) {
      if(bel[k] >= bel[idx]) {
        if(bel[k] == bel[idx]) {
          picked_pattern_num = picked_pattern_num + 1
          return idx
        }
        else {
          return k
        }
      }
      else {
        return idx
      }
    },
    pattern)
  # Set probability of picked pattern
  picked_pattern_prob = bel[picked_pattern]
}

########################################
#
# Print belief
function belief_print(bel) {
  log(id, " BELIEF")
  foreach(bel, function(k,v) {
      log("    ", k, " -> ", v)
    })
}
